import fnmatch
import subprocess
from typing import Callable, Optional

from . import errors


class RunInfo:
    """Stores the results from running a command

    :ivar cmd: see :meth:`RunInfo.__init__`
    :ivar cwd: see :meth:`RunInfo.__init__`
    :ivar pid: see :meth:`RunInfo.__init__`
    :ivar stdout: see :meth:`RunInfo.__init__`
    :ivar stderr: see :meth:`RunInfo.__init__`
    :ivar returncode: see :meth:`RunInfo.__init__`
    :ivar is_async: see :meth:`RunInfo.__init__`
    :ivar is_daemon: see :meth:`RunInfo.__init__`
    :ivar timeout: see :meth:`RunInfo.__init__`
    :ivar stdout_callback: The callback to be called when the standard output
                            stream is received  (default: None). The callback
                            should accept a single argument which is the data
                            received.
    :ivar stderr_callback: The callback to be called when the standard error
                            stream is received  (default: None). The callback
                            should accept a single argument which is the data
                            received.
    """

    def __init__(
        self,
        cmd,
        cwd,
        popen,
        stdout,
        stderr,
        returncode,
        is_async,
        is_daemon,
        timeout,
    ):
        """Create a new object

        :param cmd: The command that was executed
        :param cwd: Current working directory i.e. path where the command was executed
        :param popen: The subprocess instance for the command
        :param stdout: The standard output stream generated by the command
        :param stderr: The standard error stream generated by the command
        :param returncode: The return code set after invoking the command
        :param is_async: Whether the command was run asynchronously
        :param is_daemon: Whether the command was run as a daemon
        :param timeout: The timeout in seconds, if None then no timeout
        """

        self.cmd: str | list[str] = cmd
        self.cwd: Optional[str] = cwd
        self.popen: subprocess.Popen = popen
        self.stdout: str = stdout
        self.stderr: str = stderr
        self.returncode: Optional[int] = returncode
        self.is_async: bool = is_async
        self.is_daemon: bool = is_daemon
        self.stdout_callback: Optional[Callable] = None
        self.stderr_callback: Optional[Callable] = None
        self.timeout: Optional[int | float] = timeout

    @property
    def pid(self):
        return self.popen.pid

    def match(self, stdout=None, stderr=None):
        """Matches the lines in the output with the pattern. The match
        pattern can contain basic wildcards, see
        https://docs.python.org/2/library/fnmatch.html
        For convenience::

            +-----------------------------------------+
            |Pattern|Meaning                          |
            +-----------------------------------------+
            |*      |matches everything               |
            +-----------------------------------------+
            |?      |matches any single character     |
            +-----------------------------------------+
            |[seq]  |matches any character in seq     |
            +-----------------------------------------+
            |[!seq] |matches any character not in seq |
            +-----------------------------------------+

        Simple example::

            out.match(stdout='*success*')

        :param stdout: Pattern to search for in the list of stdout string
        :param stderr: Pattern to search for in the list of stderr string

        :raises MatchError: If the pattern is not found in the output
        """

        if stdout is not None:
            self._match(stdout, "stdout", self.stdout)

        if stderr is not None:
            self._match(stderr, "stderr", self.stderr)

    def _match(self, pattern, stream_name, output):
        """Matches the lines in the output with the pattern.

        :param pattern: Pattern to search for in the list of output string
        :param stream_name: The name of the stream to match against
        :param output: The output to match against
        """

        if output is None:
            raise errors.MatchError(
                pattern=pattern, stream_name=stream_name, output=output
            )

        match_lines = fnmatch.filter(output.splitlines(), pattern)

        if len(match_lines) == 0:
            raise errors.MatchError(
                pattern=pattern, stream_name=stream_name, output=output
            )

    def __repr__(self):
        """Return a detailed representation of the object for debugging"""
        modes = []

        if self.is_async:
            modes.append("async")
        if self.is_daemon:
            modes.append("daemon")

        return (
            f"<{self.__class__.__name__}:"
            + f" cmd: {self.cmd!r}"
            + (f" cwd: {self.cwd!r}" if self.cwd is not None else "")
            + (
                f" returncode: {self.returncode!r}"
                if self.returncode is not None
                else ""
            )
            + (f" timeout: {self.timeout!r} " if self.timeout is not None else "")
            + (f" stdout: {len(self.stdout)} chars" if self.stdout else "")
            + (f" stderr: {len(self.stderr)} chars" if self.stderr else "")
            + (f" modes: {modes!r}" if modes else "")
            + ">"
        )

    def __str__(self):
        """Print the RunInfo object as a string"""
        return self.__repr__()
